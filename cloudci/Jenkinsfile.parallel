pipeline {
    agent {
        node {
            label 'container-fedora-33-stage'
        }
    }
    environment { ARCH = "x86_64" }
    stages {
        stage("x86_64 only") {
            steps {
                script {
                    print env.CI_MESSAGE
                    def object = new groovy.json.JsonSlurperClassic().parseText(env.CI_MESSAGE)

                    def buildType = "master"
                    def non_x86_64_patch = 0

                    // To filter patch build which only has non_x86_64 patch, but has x86_64 kernel build
                    if (object.modified_files != []) {
                        buildType = "patch"
                        object.modified_files.each {
                            if (it.indexOf("arch/powerpc") == 0 || it.indexOf("arch/s390") == 0 || it.indexOf("arch/arm64") == 0 || it.indexOf("arch/openrisc") == 0){
                                non_x86_64_patch++
                            }
                        }
                    }

                    env.PIPELINE_ID = object.pipelineid

                    env.MR_URL = object.merge_request_url
                    env.MR_NUM = object.merge_request_url.split('/')[-1]

                    println non_x86_64_patch
                    println object.modified_files.size()

                    if (buildType == "master" || object.modified_files.size() != non_x86_64_patch) {
                        object.build_info.each {
                            if (it.architecture == 'x86_64') {
                                env.KERNEL_URL = it.kernel_package_url
                            }
                        }

                        env.KERNEL_NVR = env.KERNEL_URL.split('/')[-1]

                        if (buildType == "master") {
                            env.GCN_INFO = "Master"
                            currentBuild.displayName = "${env.BUILD_NUMBER}-${buildType}-${env.KERNEL_NVR}"
                        } else {
                            env.GCN_INFO = "Merge Request: ${env.MR_URL}"
                            currentBuild.displayName = "${env.BUILD_NUMBER}-${buildType}-${env.KERNEL_NVR}-MR-${env.MR_NUM}"
                        }

                        sh('printenv')
                    } else {
                        currentBuild.displayName = "${env.BUILD_NUMBER}-non_x86_64_patch_build-${env.PIPELINE_ID}-MR-${env.MR_NUM}"
                        currentBuild.result = "ABORTED"
                        error('Stopping non x86_64 patch build')
                    }
                }
            }
        }
        stage("download") {
            steps {
                download()
            }
        }
        stage("testing") {
            parallel {
                stage("n2d") {
                    agent { label "container-fedora-33-stage" }
                    environment { GCP_INSTANCE_TYPE = "n2d-standard-2" }
                    stages {
                        stage("prepare") {
                            steps {
                                prepare()
                            }
                        }
                        stage("deploy") {
                            steps {
                                deploy()
                            }
                        }
                        stage("setup") {
                            steps {
                                setup()
                            }
                        }
                        stage("install") {
                            steps {
                                install()
                            }
                            post {
                                always {
                                    archiveArtifacts allowEmptyArchive: true, artifacts: '*.serial.log'
                                }
                            }
                        }
                        stage("testing") {
                            steps {
                                run_test()
                            }
                            post {
                                always {
                                    script {
                                        env.jenkins_result = sh(returnStdout: true, script: "cat ltp.result")
                                        print env.jenkins_result
                                        switch (env.jenkins_result) {
                                            case 'PASS':
                                                currentBuild.result = "SUCCESS"
                                                break
                                            case 'FAIL':
                                                currentBuild.result = "FAILURE"
                                                break
                                        }
                                    }

                                    archiveArtifacts allowEmptyArchive: true, artifacts: 'ltp.result'
                                    archiveArtifacts allowEmptyArchive: true, artifacts: 'ltp.report'
                                    archiveArtifacts allowEmptyArchive: true, artifacts: 'results/*.result'
                                    archiveArtifacts allowEmptyArchive: true, artifacts: 'output/*.console'

                                    remove()
                                }
                            }
                        }
                    }
                }
                stage("n2") {
                    agent { label "container-fedora-33-stage" }
                    environment { GCP_INSTANCE_TYPE = "n2-standard-2" }
                    stages {
                        stage("prepare") {
                            steps {
                                prepare()
                            }
                        }
                        stage("deploy") {
                            steps {
                                deploy()
                            }
                        }
                        stage("setup") {
                            steps {
                                setup()
                            }
                        }
                        stage("install") {
                            steps {
                                install()
                            }
                            post {
                                always {
                                    archiveArtifacts allowEmptyArchive: true, artifacts: '*.serial.log'
                                }
                            }
                        }
                        stage("testing") {
                            steps {
                                run_test()
                            }
                            post {
                                always {
                                    script {
                                        env.jenkins_result = sh(returnStdout: true, script: "cat ltp.result")
                                        print env.jenkins_result
                                        switch (env.jenkins_result) {
                                            case 'PASS':
                                                currentBuild.result = "SUCCESS"
                                                break
                                            case 'FAIL':
                                                currentBuild.result = "FAILURE"
                                                break
                                        }
                                    }

                                    archiveArtifacts allowEmptyArchive: true, artifacts: 'ltp.result'
                                    archiveArtifacts allowEmptyArchive: true, artifacts: 'ltp.report'
                                    archiveArtifacts allowEmptyArchive: true, artifacts: 'results/*.result'
                                    archiveArtifacts allowEmptyArchive: true, artifacts: 'output/*.console'

                                    remove()
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    post {
        always {
            sh "rm -rf \$HOME/downloads/${env.KERNEL_NVR}"
        }
    }
    options {
        timestamps()
        timeout(time: 2, unit: 'HOURS')
    }
}

// prepare running environment
void prepare() {
    sh """
        while true; do
            test -f /usr/bin/gcloud && break
        done
    """
}

// deploy gcp instance
void deploy() {
    checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: 'kite-deploy']], submoduleCfg: [], userRemoteConfigs: [[url: 'https://github.com/virt-s1/kite-deploy.git']]])
    dir("kite-deploy") {
        withCredentials([string(credentialsId: 'gcp-project', variable: 'GCP_PROJECT'), string(credentialsId: 'gcp-service-account-name', variable: 'GCP_SERVICE_ACCOUNT_NAME'), file(credentialsId: 'gcp-service-account-file', variable: 'GCP_SERVICE_ACCOUNT_FILE')]) {
            sh "ansible-playbook -v -i inventory -e cloud_platform=gcp deploy.yaml"
        }
    }
}

// download kernel rpms
void download() {
    sh """
        ansible-playbook -v -i inventory -e cki_repo_url=${env.KERNEL_URL} download.yaml
        cat inventory
    """
}

// a lot of setup things
void setup() {
    sh """
        ansible-playbook -v -i inventory setup.yaml
        cat inventory
    """
}

// install kernel
void install() {
    withCredentials([string(credentialsId: 'gcp-project', variable: 'GCP_PROJECT')]) {
        sh """
            chmod 600 key/identity
            ansible-playbook -v -i inventory -e cloud_platform=gcp -e kernel_nvr=${env.KERNEL_NVR} -e kernel_folder=${env.HOME}/downloads/${env.KERNEL_NVR} install.yaml
        """
    }
}

// run ltp test
void run_test() {
    sh "ansible-playbook -v -i inventory run-ltp.yaml"
}

// clear gcp instance
void remove() {
    dir("kite-deploy") {
        withCredentials([string(credentialsId: 'gcp-project', variable: 'GCP_PROJECT'), string(credentialsId: 'gcp-service-account-name', variable: 'GCP_SERVICE_ACCOUNT_NAME'), file(credentialsId: 'gcp-service-account-file', variable: 'GCP_SERVICE_ACCOUNT_FILE')]) {
            sh "ansible-playbook -v -i inventory -e cloud_platform=gcp remove.yaml"
        }
    }
}
